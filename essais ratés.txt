essais ratés:

smatrix, création:
long getValue(char *s, char **endptr, char expect)
{
    long value;
    
    /* String dans lequel on copie la chaîne de caractères complète. */
    char *dim = (char *) malloc((strlen(s)+1)*sizeof(char));
    if (!dim) {
        fprintf(stderr, "Error calling malloc to handle the"
                " dimensions' string\n");
    }
    strcpy(dim, s);
    
    /* Nombre de lignes. */
    printf("avant 2ble pointeur : %s\n", *endptr);
    value = strtol(dim, endptr, 10);
    printf("après 2ble pointeur : %s\n", *endptr);
    free(dim);
    
    /* Le format n'est pas respecté. */
    if(**endptr != expect)
    {
        printf("expect: %c\n", expect);
        fprintf(stderr,"Error :  the file encoding is incorrect. Each matrix\n"
                "\t should start with a dimensions' line as follows :\n"
                "\t LxC where L and C are the number of lines and columns. \n");
        return 0;
    }
    
    return value;
}


main, remplir la matrice:
        /* boucle sur les lignes pour remplir la matrice créée */
        for (line = 0; line < current->n ; line++) {
            printf("line %ld du fichier en lecture \n", line);
            /* on lit ligne par ligne */
            read = getline(&snippet, &len, ides);
            if (read <= 0) {
                fprintf(stderr, "Error calling getline \n");
                if (snippet) {
                    free(snippet); snippet = NULL;
                }
                exit_status = EXIT_FAILURE;
                goto free_matrixes;
            }
            printf("passé le 2e read : %s\n", snippet);
            // buffer qui contient le reste de la ligne à convertir en nombres
            char *endptr;
            
            // buffer qui contient la ligne en entier
            char *content = (char *) malloc(strlen(snippet)+1)*sizeof(char));
            if (!content) {
                fprintf(stderr, "Error calling malloc to read the file\n");
                if (snippet) {
                    free(snippet); snippet = NULL;
                }
                exit_status = EXIT_FAILURE;
                goto free_matrixes;
            }
            strcpy(content, snippet);
            printf("passé le copy : %s\n", snippet);
            
            /* boucle sur la ligne pour récupérer les valeurs */
            for (col = 0; col < current->m; col++) {
                printf("col %ld du fichier en lecture \n", col);
                val = strtol(content, &endptr, 10);
                
                if (val == 0) {
                    // A REVOIR
                    // if the value is 0, do not enqueue
                } else {
                    printf("appel de fill avec val %ld\n", val);
                    
                    if (fillSmatrix(current, line, col, val) != 0) {
                        fprintf(stderr, "Error calling fillSMmatrix\n");
                        if (snippet) {
                            free(snippet); snippet = NULL;
                        }
                        if (content) {
                            free(content); content = NULL;
                        }
                        exit_status = EXIT_FAILURE;
                        goto free_matrixes;
                    }
                }
                
                // copy the rest of the line into the buffer
                strcpy(content, endptr);
            }
            free(content); content = NULL;
        }